%include "stud_io.inc"
global input_string_repr


; input_string_repr(адрес начала строки, длина строки)
; -> eax - количество разрядов числа (знак тоже разряд), ecx - код завершения
; (0 - успех, 1 - число не введено, -1 - eof, -2 - overflow,
; 'код символа' - была введена не цифра)
input_string_repr: ; ввод строкового представления числа
        push ebp                ; сохраняем ebp
        mov ebp, esp            ; ставим ebp на вершину стека

        push edi                ; сохраняем edi

        mov ecx, [ebp + 8]      ; в ecx длина строки
        mov edi, [ebp + 12]     ; в edi адрес начала строки

        cld                     ; строковые операции в прямом направлении
.input_sign: ; вводим знак
        GETCHAR                 ; считываем символ в al

        cmp al, '+'             ; символ +?
        je .sign                ; если да, то ставим в первый разряд знак

        cmp al, '-'             ; символ -?
        je .sign                ; если да, то ставим в первый разряд знак
; может ввели цифру?
        sub al, '0'             ; вычитаем код нуля (преобразуем в цифру)
        cmp al, 9               ; текущий символ - цифра?
        jnbe .not_digit         ; если нет, то прыгаем

; ввели цифру, не передавая знак числа -> число неотрицательно
        mov byte [edi], '+'     ; сохраняем знак '+' в первый разряд
        inc edi                 ; edi += 1

        add al, '0'             ; восстанавливаем цифру
        stosb                   ; сохраняем цифру
        sub ecx, 2              ; ecx -= 2 (введены знак и первая цифра)

        jmp .lp                 ; прыгаем на ввод числа
.sign: ; ставим знак (передан явно)
        stosb                   ; записываем знак
        dec ecx                 ; ecx -= 1 (введён знак)
.lp: ; ввод числа
        GETCHAR                 ; считываем символ в al

        sub al, '0'             ; вычитаем код нуля (преобразуем в цифру)
        cmp al, 9               ; текущий символ - цифра?
        jnbe .not_digit         ; если нет, то прыгаем
; ввели цифру
        jecxz .overflow         ; если получилось переполнение, то ошибка
; переполнения не случилось
        add al, '0'             ; восстанавливаем цифру
        stosb                   ; сохраняем цифру
        dec ecx                 ; ecx -= 1 (введена ещё одна цифра)

        jmp .lp                 ; продолжаем ввод

.overflow: ; обработка переполнения
        xor eax, eax            ; число не было введено
        mov ecx, -2             ; произошло переполнение
        jmp .quit               ; завершаем п/программу

.not_digit: ; обработка символа, не являющегося цифрой
        add al, '0'             ; восстанавливаем символ

        cmp al, ' '             ; символ - пробел?
        je .completed           ; если да, то ввод окончен

        cmp al, 10              ; символ - перенос?
        je .completed           ; если да, то ввод окончен

        cmp al, -1              ; символ - конец файла?
        je .eof                 ; если да, то ошибка конца файла

        mov ecx, eax            ; ecx = коду ошибочного символа
        xor eax, eax            ; число не было введено
        jmp .quit               ; завершаем п/программу

.eof: ; обработка конца файла
        xor eax, eax            ; число не было введено
        mov ecx, -1             ; произошло событие конца файла
        jmp .quit               ; завершаем п/программу

.nan: ; число не было введено (0 разрядов, либо только знак)
        xor eax, eax            ; число не было введено
        mov ecx, 1              ; произошла ошибка ввода числа
        jmp .quit               ; завершаем п/программу

.completed: ; окончание ввода
        mov eax, [ebp + 8]      ; вычисляем количество разрядов числа
        sub eax, ecx            ; (из максимального вычитаем кол. оставшихся)

        cmp eax, 1              ; если разрядов 0 (число не введено) или 1
        jna .nan                ; (введён только знак), то произошла ошибка NaN
; ошибок не случилось
        xor ecx, ecx            ; число введено успешно

.quit: ; завершение п/программы
        pop edi                 ; восстанавливаем edi

        mov esp, ebp            ; восстанавливаем esp
        pop ebp                 ; восстанавливаем ebp
        ret 8                   ; возвращаем управление с очисткой стека
